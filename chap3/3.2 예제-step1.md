## 3.2 예제

모든 예제는 아래가 준비되어 있다는 전제 하에 진행됩니다.

Proxmox VM 템플릿: OS 설치 및 cloud-init 설정이 완료된 VM 템플릿이 Proxmox에 준비되어 있어야 합니다. 이 예제에서는 템플릿의 이름이 ubuntu-2204-template이라고 가정하겠습니다.

1단계: 단일 파일을 사용하여 VM 생성하기

```bash
mkdir step1 && cd step1
vi step1.tf

# 사용할 프로바이더와 버전 설정
terraform {
  required_providers {
    proxmox = {
      # 참고: 이 코드는 telmate/proxmox 프로바이더 문법을 기준으로 합니다.
      source  = "telmate/proxmox"
      version = "3.0.2-rc06"
    }
  }
}

# Proxmox 프로바이더 구성
provider "proxmox" {
  pm_api_url          = "https://192.168.0.3:8006/api2/json"
  pm_api_token_id     = "terraform-prov@pve!terraform-token"
  pm_api_token_secret = "e3f31683-a95e-42c3-****"

  # 자체 서명 인증서 사용 시 필요
  pm_tls_insecure = true
}

# Proxmox VM 리소스 정의
resource "proxmox_vm_qemu" "ubuntu_vm" {
  # VM의 이름 설정
  name        = "kosa-vm-01"
  # VM이 배포될 Proxmox 노드의 이름
  target_node = "masungil1"
  # 복제할 템플릿의 이름
  clone       = "ubuntu-2204-template"
  # VM 생성 시 풀 클론(독립적인 복사본)을 수행할지 여부
  full_clone  = true

  # 운영체제 타입 설정 (Cloud-Init을 사용)
  os_type = "cloud-init"
  # QEMU Guest Agent 활성화 (VM과 호스트 간 통신)
  #agent   = 1

  # CPU 설정
  cpu {
    # 할당할 CPU 코어 수
    cores = 1
    # 할당할 CPU 소켓 수
    sockets = 1
  }

  # 할당할 메모리 양 (MB 단위)
  memory = 1024
  # SCSI 컨트롤러 하드웨어 타입 (성능 향상을 위해 VirtIO SCSI 권장)
  scsihw  = "virtio-scsi-pci"
  # 부팅 순서 (scsi0 디스크로 부팅)
  boot    = "order=scsi0"

  # 메인 디스크 설정 (루트 디스크)
  disk {
    # 디스크 슬롯 (scsi0)
    slot    = "scsi0"
    # 디스크 크기 (8GB)
    size    = "8G"
    # 디스크 종류 (일반 디스크)
    type    = "disk"
    # 디스크 저장소 (예: local-lvm)
    storage = "local-lvm"
  }

  # Cloud-Init 드라이브 설정
  disk {
    # 디스크 슬롯 (ide2는 일반적으로 Cloud-Init CD-ROM 드라이브에 사용)
    slot    = "ide2"
    # 디스크 종류 (Cloud-Init 드라이브)
    type    = "cloudinit"
    # 디스크 저장소
    storage = "local-lvm"
  }


  # 네트워크 인터페이스 설정
  network {
    # 네트워크 인터페이스 ID (net0)
    id     = 0
    # 네트워크 카드 모델 (VirtIO는 성능이 좋음)
    model  = "virtio"
    # 연결할 가상 브릿지
    bridge = "vmbr0"
  }

  # Cloud-Init을 통한 IP 설정 (DHCP로 IP 자동 할당)
  ipconfig0 = "ip=dhcp"

  # Cloud-Init 업그레이드 활성화
  ciupgrade  = true
  # Cloud-Init 사용자 이름
  ciuser     = "kosa"
  # Cloud-Init 사용자 암호
  cipassword = "kosa1004"

  # VGA 설정
  vga {
    # VGA 타입 (표준)
    type = "std"
  }

  # Terraform 라이프사이클 관리 설정
  lifecycle {
    # 특정 속성의 변경을 Terraform이 무시하도록 설정 (수동 변경 시 유용)
    ignore_changes = [
      network, # 네트워크 설정 변경 무시
      disk     # 디스크 설정 변경 무시
    ]
  }
}
```

---

### terraform 명령어

- terraform init
- terraform plan
- terraform apply
- terraform destroy

---

#### terraform init

terraform init 은 Terraform 프로젝트 작업을 시작하기 위해 가장 먼저 실행해야 하는 필수적인 초기화 명령어입니다.

주요 기능은 다음과 같습니다:

- 프로바이더 플러그인 다운로드: .tf 파일에 정의된 프로바이더(예: proxmox)에 해당하는 플러그인을 다운로드하여 .terraform/providers 디렉토리에 저장합니다.
- 백엔드 초기화: terraform.tfstate 파일이 저장될 백엔드(기본값은 로컬, 원격 백엔드도 설정 가능)를 설정하고 준비합니다.
- 모듈 설치: 구성에 사용된 원격 모듈의 소스 코드를 다운로드하여 .terraform/modules 디렉토리에 저장합니다.

- 이 명령어는 프로젝트를 처음 시작할 때, 또는 프로바이더, 모듈, 백엔드 설정에 변경이 있을 때마다 다시 실행해야 합니다.

아래 명령을 입력하고 terraform 초기화를 진행합니다 

```bash
terraform init
```

---

#### terraform plan

terraform plan은 작성된 Terraform 코드를 실제 인프라에 적용하기 전에, 어떤 변경이 일어날지 미리 보여주는 '실행 계획' 또는 '미리보기'를 생성하는 명령어입니다.

가장 중요한 특징은 실제 인프라에는 어떠한 변경도 가하지 않기 때문에 매우 안전하고 중요한 단계라는 점입니다.

레고 조립에 비유하자면, init이 부품을 준비하는 과정이었다면, plan은 설명서를 보고 다음 단계에서 어떤 부품을 추가하고, 어떤 부품을 떼어내고, 어떤 부품을 교체할지 미리 확인해보는 과정과 같습니다. 아직 실제 레고 모델을 만지지는 않은 상태입니다.

- terraform plan의 동작 원리

terraform plan을 실행하면 내부적으로 다음 세 가지 단계를 거칩니다.

  1. 코드 읽기 (Desired State): Terraform은 현재 디렉토리의 모든 .tf 파일을 읽어 사용자가 '원하는 인프라 상태(Desired State)'가 무엇인지 파악합니다.
  2. 상태 파일 읽기 (Current State): 그 다음, terraform.tfstate 파일(Terraform이 관리하는 인프라의 현재 상태 기록)을 읽어 '현재 인프라 상태(Current State)'가 무엇인지 파악합니다.
  3. 비교 및 실행 계획 생성 (Compare and Create Plan): 위 두 상태를 비교하여, '원하는 상태'를 만들기 위해 '현재 상태'에서 어떤 작업이 필요한지 결정합니다. 이것이 바로 '실행 계획(Execution Plan)'이며, 이 계획을 화면에 출력해 줍니다.

실행 계획(Plan) 결과 읽는 법

terraform plan의 결과에는 다음과 같은 기호와 정보가 표시됩니다.

  * `+` (초록색): 생성(Create)될 리소스를 의미합니다. 코드에는 있지만 현재 상태에는 없는 새로운 리소스입니다.
  * `-` (빨간색): 삭제(Destroy)될 리소스를 의미합니다. 현재 상태에는 있지만 코드에서는 제거된 리소스입니다.
  * `~` (노란색): 변경(Update in-place)될 리소스를 의미합니다. 리소스의 일부 속성(예: VM의 태그)이 변경되어 리소스를 삭제하지 않고 속성만 업데이트합니다.
  * `-/+` (빨갛고 초록색): 교체(Replace)될 리소스를 의미합니다. 리소스의 핵심 속성(예: VM의 이미지 ID)이 변경되어, 기존 리소스를 삭제하고 새로 생성해야 합니다.

명령의 마지막에는 `Plan: X to add, Y to change, Z to destroy.` 와 같이 전체 변경 사항을 요약해서 보여주어 한눈에 파악하기 쉽게 해줍니다.

핵심 기능: 계획 파일 저장 (-out 옵션)

terraform plan은 단순히 화면에 결과를 보여주는 것 이상의 중요한 기능이 있습니다. 바로 실행 계획을 파일로 저장하는 기능입니다.

```bash
terraform plan -out=myplan.tfplan
```

이렇게 하면 생성된 실행 계획이 myplan.tfplan이라는 바이너리 파일에 저장됩니다. 그리고 이 파일을 사용하여 apply를 실행할 수 있습니다.

```bash
terraform apply "myplan.tfplan"
```

왜 이 기능이 중요할까요?

plan을 실행하고 apply를 실행하는 사이에 누군가 수동으로 인프라를 변경하거나, 코드가 변경될 수 있습니다. 이 경우, plan에서 봤던 내용과 다른 작업이 apply 때 실행될 수 있어 위험합니다.

계획 파일을 사용하면, apply는 정확히 plan 시점에 생성된 계획 파일의 내용대로만 실행됩니다. 이것은 'Plan-Apply' 워크플로우의 핵심으로, `plan`에서 확인한 내용과 `apply`에서 실행될 내용이 100% 동일함을 보장합니다.

---

#### terraform apply

terraform apply는 terraform plan을 통해 생성하고 검토한 실행 계획을 실제로 인프라에 적용하여 리소스를 생성, 수정, 삭제하는 명령어입니다. 즉, Terraform 워크플로우의 '실행' 단계에 해당합니다.

레고 조립에 비유하자면, plan에서 확인한 설명서대로 실제로 부품을 조립하여 모델을 완성하거나 변경하는 마지막 과정입니다. 이 명령어를 실행하면 실제 비용이 발생하는 인프라 자원이 생성되거나 변경될 수 있으므로 신중하게 사용해야 합니다.

terraform apply의 두 가지 실행 방식

terraform apply는 어떻게 실행하는지에 따라 두 가지 방식으로 동작합니다.

1. terraform apply (계획 파일 없이 실행)

가장 기본적인 사용법입니다. 이 명령어를 실행하면 다음과 같은 절차를 따릅니다.

  1. 자동으로 `plan` 실행: 먼저 terraform plan을 내부적으로 실행하여 현재 코드와 실제 인프라 상태를 비교하고 실행 계획을 생성합니다.
  2. 계획 표시: 생성된 실행 계획을 화면에 보여주며 어떤 리소스가 생성(+), 변경(~), 또는 삭제(-)될지 알려줍니다.
  3. 사용자에게 실행 여부 확인: 화면에 `Do you want to perform these actions?` 라는 확인 질문을 표시하고 사용자의 입력을 기다립니다.
    * `yes` 를 직접 입력해야만 다음 단계로 진행합니다.
    * yes가 아닌 다른 값을 입력하거나 그냥 Enter를 누르면 작업은 안전하게 취소됩니다.
  4. 실행: 사용자가 yes를 입력하면, Terraform은 계획에 따라 실제로 클라우드 제공업체(예: Proxmox, AWS)의 API를 호출하여 인프라를 변경합니다.

이 확인 과정은 실수로 중요한 인프라를 변경하거나 삭제하는 것을 방지하는 매우 중요한 안전장치입니다.

2. terraform apply "planfile" (계획 파일을 사용하여 실행)

terraform plan -out=myplan.tfplan 명령어로 생성된 계획 파일을 인자로 전달하여 실행하는 방식입니다.

  1. 계획 파일 읽기: 새로운 계획을 생성하지 않고, 지정된 myplan.tfplan 파일을 읽습니다.
  2. 확인 질문 없이 즉시 실행: 별도의 확인 질문을 하지 않고 즉시 계획 파일에 명시된 내용대로 인프라 변경을 시작합니다.
  3. 실행: 계획 파일의 내용에 따라 인프라를 변경합니다.

> 이 방식은 `plan` 단계에서 검토한 내용이 그대로 적용됨을 100% 보장하기 때문에 CI/CD 파이프라인과 같은 자동화 환경에 매우 적합하며, 가장 안전하고 권장되는 모범 사례입니다.

3. terraform apply -auto-approve

terraform apply 실행 시 나타나는 변경 사항 확인 프롬프트(`Do you want to perform these actions?`)를 자동으로 'yes'로 응답하여 건너뛰는 옵션입니다.

이 옵션은 매우 편리하지만, 매우 위험할 수도 있으므로 신중하게 사용해야 합니다.

terraform apply -auto-approve의 동작

  * 일반적인 `terraform apply`: 먼저 실행 계획을 보여주고, 사용자가 화면에 직접 yes를 입력해야만 실제 인프라 변경이 시작됩니다. 이 확인 과정은 실수 방지를 위한 중요한 안전장치입니다.
  * `terraform apply -auto-approve`: 이 옵션을 사용하면 위에서 언급한 yes 입력 과정을 생략하고, plan 단계에서 예상되는 모든 변경 사항을 즉시 인프라에 적용합니다. 즉, 새로운 실행 계획을 만들고 자동으로 승인하여 바로 적용하는 것과 같습니다.

주요 사용 사례

1. 자동화된 환경 (CI/CD 파이프라인):
  * 가장 일반적이고 필요한 경우입니다. CI/CD 파이프라인과 같이 사람이 직접 yes를 입력할 수 없는 비대화형(non-interactive) 환경에서 Terraform을 자동으로 배포할 때 사용됩니다.
  * 예를 들어, 코드 푸시(push) 시 자동으로 인프라를 배포하거나 업데이트하는 경우에 활용됩니다.

2. 스크립트 내부:
  * 간단한 테스트 스크립트나 자동화된 유지보수 스크립트에서 확인 단계를 생략하고 싶을 때 사용될 수 있습니다.

사용 시 주의사항 및 위험성 (매우 중요!)

auto-approve 옵션은 편리함과 동시에 다음과 같은 큰 위험을 내포하고 있습니다.

  1. 수동 검토 생략: 이 옵션은 최종 실행 계획을 사람이 직접 검토할 기회를 완전히 제거합니다. 만약 Terraform 코드에 실수나 의도치 않은 변경 사항이 포함되어 있다면, -auto-approve는 이를 확인 없이 실제 인프라에 적용하게 됩니다.
  2. 예측 불가능한 변경: terraform plan을 실행한 시점과 terraform apply -auto-approve를 실행하는 시점 사이에 코드나 클라우드 제공업체의 인프라 상태가 변경되었다면, 실제로 적용되는 계획이 plan 단계에서 예상했던 것과 달라질 수 있습니다. -auto-approve는 새롭게 생성된 (그리고 변경되었을 수 있는) 계획을 자동으로 승인해버립니다.
  3. 실수와 재해: 프로덕션 환경에서는 -auto-approve 옵션의 사용을 절대적으로 피해야 합니다. 작은 실수라도 치명적인 서비스 중단이나 데이터 손실로 이어질 수 있으며, 복구하기 매우 어려울 수 있습니다.

권장되는 자동화 워크플로우 (더 안전한 방법)

자동화 환경에서 terraform apply -auto-approve 대신 `terraform plan -out=myplan.tfplan`으로 계획 파일을 먼저 생성하고, `terraform apply "myplan.tfplan"`으로 해당 계획 파일을 적용하는 것이 훨씬 안전한 방법 입니다.

  * 이 방식은 plan 단계에서 확정된 계획만이 apply될 것을 보장하여, plan과 apply 사이의 예측 불가능한 변경 위험을 제거합니다.
  * CI/CD 파이프라인에서는 plan 단계에서 생성된 계획 파일을 아티팩트로 저장하고, 개발자 또는 관리자의 수동 승인 후 apply 단계에서 해당 계획 파일을 적용하는 방식으로 구현하는 것이 일반적입니다.

결론적으로, `terraform apply -auto-approve`는 자동화를 위한 강력한 도구이지만, 그만큼 큰 위험을 내포하고 있습니다. 사용 목적과 상황을 명확히 이해하고, 가능한 경우에는 계획 파일을 사용하는 안전한 워크플로우를 따르는 것이 중요합니다.

작업 완료 후

apply가 성공적으로 실행되면, Terraform은 변경된 인프라의 최종 상태를 terraform.tfstate 파일에 기록합니다. 이 상태 파일은 다음 plan 또는 apply를 위한 최신 기준으로 사용되어 지속적으로 인프라를 관리할 수 있게 해줍니다.

---

#### terraform destroy

terraform destroy는 Terraform으로 관리되는 모든 인프라 리소스를 영구적으로 삭제(제거)하는 명령어입니다. terraform apply가 인프라를 생성하고 구성하는 것의 완벽한 반대 역할을 합니다.

매우 강력하고 위험할 수 있는 명령어이므로 그 의미와 결과를 정확히 이해하고 사용해야 합니다.

레고 조립에 비유하자면, apply로 완성한 레고 모델을 완전히 분해하여 모든 부품을 상자로 되돌리는 과정입니다. 한번 실행하면 조립했던 모델은 그대로 사라집니다.

terraform destroy의 동작 원리

terraform destroy를 실행하면 apply와 유사하지만 반대의 절차를 따릅니다.

1. 상태 파일 읽기 (Read State File): terraform.tfstate 파일을 읽어 현재 Terraform이 어떤 리소스들을 관리하고 있는지 파악합니다.
2. 삭제 계획 생성 (Create Destruction Plan): 상태 파일에 기록된 모든 리소스를 삭제하는 계획을 세웁니다. terraform plan과 유사한 출력을 보여주지만, 모든 리소스가 `-` (삭제)로 표시됩니다.
3. 계획 표시 및 사용자 확인 (Show Plan and Confirm):
  * 화면에 곧 삭제될 모든 리소스의 목록을 보여줍니다.
  * `Do you really want to destroy all resources?` 와 같이, 작업이 파괴적임을 경고하는 매우 중요한 확인 질문을 합니다.
  * 사용자가 반드시 `yes`를 직접 입력해야만 삭제 작업이 시작됩니다. 이 과정은 치명적인 실수를 막기 위한 마지막 안전장치입니다.
4. 리소스 삭제 실행 (Execute Destruction): 사용자가 yes를 입력하면, Terraform은 클라우드 제공업체의 API를 호출하여 계획된 모든 리소스를 삭제합니다. (예: Proxmox VM 종료 및 삭제, AWS EC2 인스턴스 종료 등)
5. 상태 파일 업데이트 (Update State File): 모든 리소스가 성공적으로 삭제되면, terraform.tfstate 파일에서 해당 리소스 기록을 모두 삭제하여 상태를 깨끗하게 비웁니다.

주요 옵션 및 경고

* `terraform destroy -auto-approve`
* 사용자에게 yes를 입력받는 확인 과정을 건너뛰고 즉시 삭제를 진행합니다.
* 매우 위험합니다. 자동화된 CI/CD 파이프라인에서 테스트 후 생성된 임시 환경을 확실하게 제거할 목적이 아니라면 절대 사용해서는 안됩니다.

* `terraform destroy -target=<리소스 주소>`
* 전체 리소스가 아닌 특정 리소스 하나만 지정하여 삭제할 수 있습니다.
* 경고: Terraform 공식 문서에서는 이 옵션을 일상적인 작업에 사용하는 것을 강력히 권장하지 않습니다. 리소스 간의 의존성 문제로 인해 전체 인프라 상태가 꼬이거나 예측 불가능한 부작용을 초래할 수 있기 때문입니다. 시스템 복구나 예외적인 상황에서만 사용을 고려해야 합니다.

요약

terraform destroy는 '선언된 인프라를 깨끗하게 정리'하는 강력하고 필수적인 도구입니다. apply로 쉽게 생성했던 모든 것을 반대로 쉽게 제거할 수 있게 해줍니다.

하지만 그 파괴적인 특성 때문에, 실행하기 전에는 항상 어떤 리소스들이 삭제될 것인지 목록을 두 번, 세 번 확인하는 습관이 매우 중요합니다.

---

#### 실행 방법:

```bash
terraform init
terraform plan
terraform apply -auto-approve
```

생성된 가상 머신에 접속해 봅니다
userid : kosa
password : kosa1004 을 입력하면 로그인이 되는 것을 확인할 수 있습니다

생성된 가상머신의 요약에 부분에 IP 주소가 표시되지 않습니다.
