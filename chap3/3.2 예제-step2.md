## 3.2 기본예제

2단계: 지역변수 처리하는 방법

Terraform 설정 파일 내에서 사용할 '지역 변수' 또는 '별명'을 만드는 기능은 locals 블럭을 사용하는 것 입니다. 코드를 더 깔끔하고, 읽기 쉽고, 유지보수하기 좋게 만드는 데 큰 도움이 됩니다.

step2.tf의 locals 분석

해당 파일의 locals 블록은 다음과 같습니다.

```
#...
locals {
  name          = "kosa-vm-02"
  template_name = "ubuntu-2204-template"
  target_node   = "masungil1"
}
#...
```

그리고 이 값들은 proxmox_vm_qemu 리소스에서 다음과 같이 사용됩니다.
```
#...
resource "proxmox_vm_qemu" "ubuntu_vm" {
  name        = local.name          # "kosa-vm-02"
  clone       = local.template_name # "ubuntu-2204-template"
  target_node = local.target_node   # "masungil1"
# ...
}

* locals 블록 안에 name, template_name, target_node라는 세 개의 지역 변수를 정의했습니다.
* 각 변수에는 VM의 이름, 사용할 템플릿 이름, 배포할 Proxmox 노드 이름이라는 구체적인 값이 할당되어 있습니다.
* resource 블록에서는 local. 이라는 접두사를 사용하여 이 변수들을 참조합니다. (local.name, local.target_node 등)

locals를 사용하는 이유 (장점)

1. 유지보수 용이성 (Ease of Maintenance)
  * 가장 큰 장점입니다. 만약 VM의 이름을 "kosa-vm-03"으로 바꾸고 싶다면, locals 블록의 name 값만 수정하면 됩니다. locals를 사용하지 않았다면, resource 블록 내부의 name 속성을 직접 찾아 수정해야 했을 것입니다. 코드가 길어지고 여러 리소스에서 동일한 이름을 참조하는 복잡한 상황이라면, locals는 단 한 곳만 수정하면 되므로 매우 편리하고 실수를 줄여줍니다.

2. 가독성 향상 (Improved Readability)
  * 파일 상단에 주요 설정값(변수)들이 모여 있어, 이 코드가 '어떤 이름의 VM을, 어떤 템플릿을 사용하여, 어느 노드에 만드는가'를 한눈에  파악하기 쉽습니다.

3. 반복 제거 (DRY: Don't Repeat Yourself)
  * 하나의 값을 여러 곳에서 사용해야 할 때, locals에 한 번만 정의하고 여러 번 참조할 수 있습니다. 이렇게 하면 같은 내용을 반복해서 입력할 필요가 없고, 오타와 같은 실수를 방지할 수 있습니다.


```bash
mkdir step2 && cd step2
vi step2.tf

# 공통으로 사용할 변수들을 locals 블록에 정의하여 유지보수 용이성을 높임
locals {
  name          = "kosa-vm-02"
  template_name = "ubuntu-2204-template"
  target_node   = "masungil1"
}

resource "proxmox_vm_qemu" "ubuntu_vm" {
  # VM의 이름 설정
  name        = local.name
  # VM이 배포될 Proxmox 노드의 이름
  target_node = local.target_node
  # 복제할 템플릿의 이름
  clone       = local.template_name
  # VM 생성 시 풀 클론(독립적인 복사본)을 수행할지 여부
  full_clone  = true

  # 운영체제 타입 설정 (Cloud-Init을 사용)
  os_type = "cloud-init"
  # QEMU Guest Agent 활성화 (VM과 호스트 간 통신)
  agent   = 1

  # CPU 설정
  cpu {
    # 할당할 CPU 코어 수
    cores = 1
    # 할당할 CPU 소켓 수
    sockets = 1
  }

  # 할당할 메모리 양 (MB 단위)
  memory  = 1024
  # 메모리 벌루닝 활성화 (최소 512MB 보장)
  balloon = 512
  # SCSI 컨트롤러 하드웨어 타입 (성능 향상을 위해 VirtIO SCSI 권장)
  scsihw  = "virtio-scsi-pci"
  # 부팅 순서 (scsi0 디스크로 부팅)
  boot    = "order=scsi0"

  # 메인 디스크 설정 (루트 디스크)
  disk {
    # 디스크 슬롯 (scsi0)
    slot    = "scsi0"
    # 디스크 크기 (8GB)
    size    = "8G"
    # 디스크 종류 (일반 디스크)
    type    = "disk"
    # 디스크 저장소 (예: local-lvm)
    storage = "local-lvm"
  }

  # Cloud-Init 드라이브 설정
  disk {
    # 디스크 슬롯 (ide2는 일반적으로 Cloud-Init CD-ROM 드라이브에 사용)
    slot    = "ide2"
    # 디스크 종류 (Cloud-Init 드라이브)
    type    = "cloudinit"
    # 디스크 저장소
    storage = "local-lvm"
  }


  # 네트워크 인터페이스 설정
  network {
    # 네트워크 인터페이스 ID (net0)
    id     = 0
    # 네트워크 카드 모델 (VirtIO는 성능이 좋음)
    model  = "virtio"
    # 연결할 가상 브릿지
    bridge = "vmbr0"
  }

  # Cloud-Init을 통한 IP 설정 (DHCP로 IP 자동 할당)
  ipconfig0 = "ip=dhcp"

  # Cloud-Init 업그레이드 활성화
  ciupgrade  = true
  # Cloud-Init 사용자 이름
  ciuser     = "kosa"
  # Cloud-Init 사용자 암호
  cipassword = "kosa1004"

  # VGA 설정
  vga {
    # VGA 타입 (표준)
    type = "std"
  }

  # Terraform 라이프사이클 관리 설정
  lifecycle {
    # 특정 속성의 변경을 Terraform이 무시하도록 설정 (수동 변경 시 유용)
    ignore_changes = [
      network, # 네트워크 설정 변경 무시
      disk     # 디스크 설정 변경 무시
    ]
  }
}

```

#### 실행 방법:
```bash
terraform init
terraform plan
terraform apply -auto-approve
```


생성된 가상 머신에 접속해 봅니다
```
userid : kosa
password : kosa1004
```
입력하면 로그인이 되는 것을 확인할 수 있습니다

주의 terraform 실행 시간의 2분이상 걸리는 이유

agent = 1이 설정되서 설치된 가상머신에 qemu-guest-agent가 설치되는 것을 확인 해야 terraform이 종료되는데 현재 template 이미지는 설치되지 않아 2분가 대기 하다 종료합니다

생성된 가상머신의 요약에 부분에 IP 주소가 표시되지 않습니다.
