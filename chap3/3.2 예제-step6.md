### 초기설정 과정

1. 초기 설정 과정이란?

Terraform 등으로 VM을 막 생성한 상태는, 운영체제(OS)만 덩그러니 설치된 '빈 집'과 같습니다. 이 빈 집에 사람이 살거나(애플리케이션이 실행되거나) 외부인이 방문할 수 있도록(서비스가 가능하도록) 내부를 꾸미는 과정이 바로 초기 설정입니다.

- 애플리케이션 실행 환경 구축:
  기본 OS 이미지에는 웹 서버(Nginx), 프로그래밍 언어(Java, Python), 데이터베이스(MySQL) 등이 설치되어 있지 않습니다. 애플리케이션이 동작하는 데 필요한 모든 소프트웨어를 설치하고 설정해야 합니다.

- 보안 강화 (Security Hardening):
  기본 이미지는 범용성을 위해 보안이 최소한으로 설정되어 있습니다. 해킹 등의 위협으로부터 서버를 보호하기 위해 SSH 루트 로그인 비활성화, 방화벽 설정, 불필요한 포트 차단, 보안 에이전트 설치 등의 조치가 필수적입니다.

- 관리 및 모니터링 환경 구성:
  서버를 안정적으로 운영하고 장애 발생 시 원인을 파악하기 위해 관리자 계정을 만들고, 시간대(Timezone)를 설정하며, 서버의 상태(CPU, 메모리등)를 수집하는 모니터링 에이전트를 설치해야 합니다.

- 일관성 및 재현성 확보:
  개발, 테스트, 운영 환경의 서버 설정이 모두 동일해야 "내 PC에서는 됐는데 서버에서는 안 돼요"와 같은 문제를 막을 수 있습니다. 모든 설정 과정을 코드로 자동화함으로써, 언제 누가 만들어도 100% 동일한 서버를 만들 수 있습니다(재현성).

2. 초기 설정이 필요한 상황 (When?)

사실상 기본 OS 이미지를 사용하여 의미 있는 작업을 하는 모든 서버를 만들 때 초기 설정 과정이 필요하다고 볼 수 있습니다.

- 웹/API 서버 구축 시: Nginx, Apache, Node.js, Tomcat 등 웹 관련 소프트웨어를 설치하고 서비스로 등록해야 할 때.
- 데이터베이스 서버 구축 시: MySQL, PostgreSQL 등을 설치하고 초기 데이터베이스 생성, 사용자 계정 설정, 원격 접속 허용 등의 작업을 해야 할 때.
- CI/CD 실행 에이전트(Runner) 구성 시: GitLab Runner, Jenkins Agent를 설치하고 Docker, Java, Git 등 코드 빌드에 필요한 도구들을 설치해야 할 때.
- 클라우드/가상화 환경에서 VM을 생성할 때: 클라우드에서 제공하는 기본 이미지는 최소한의 기능만 담고 있으므로, 거의 모든 경우에 비즈니스 로직 수행을 위한 추가 설정이 필요합니다.

3. 초기 설정 과정을 처리하는 방법 (How?)

초기 설정을 자동화하는 방법은 여러 가지가 있으며, 상황과 복잡도에 따라 적절한 방법을 선택할 수 있습니다.

- 방법 1: 셸 스크립트 실행 (간단한 작업용)
  - 설명: 필요한 명령어들을 셸 스크립트(.sh 파일)로 작성하여 VM이 처음 부팅될 때 한 번 실행되도록 하는 방식입니다.
  - 도구:
    - Cloud-Init: 클라우드 환경의 표준 방식으로, user-data에 스크립트를 담아 VM에 전달합니다.
    - Terraform `remote-exec`: Terraform이 SSH로 VM에 접속하여 스크립트 내용을 직접 실행합니다.
  - 장점: 배우기 쉽고 간단한 작업을 빠르게 자동화할 수 있습니다.
  - 단점: 스크립트가 길어지면 관리가 어렵고, 여러 번 실행했을 때 결과가 달라질 수 있습니다(멱등성 보장 안됨).

- 방법 2: 구성 관리 도구 사용 (복잡/반복 작업용)
  - 설명: "서버가 최종적으로 어떤 상태여야 하는지"를 선언적인 코드(주로 YAML)로 정의합니다. 그러면 도구가 알아서 현재 상태와 목표 상태의 차이를 계산하여 필요한 작업만 수행합니다.
  - 도구: Ansible(가장 널리 쓰이며 추천), Puppet, Chef
  - 장점: 여러 번 실행해도 항상 동일한 결과가 보장됩니다(멱등성). 코드를 재사용하기 좋고 복잡한 설정도 체계적으로 관리할 수 있습니다.
  - 단점: 해당 도구에 대한 별도의 학습이 필요합니다.

- 방법 3: 골든 이미지 사용 (대규모/고속 배포용)
  - 설명: 초기 설정이 모두 완료된 상태의 VM 템플릿(골든 이미지)을 미리 만들어 둡니다. VM을 생성할 때는 이 이미지를 그대로 복제만 하므로 설정 과정이 아예 생략됩니다.
- 도구: Packer
  - 장점: VM 배포 속도가 가장 빠르고, 모든 VM의 환경이 완벽하게 동일함을 보장합니다.
  - 단점: 이미지를 만들고 버전 관리하는 별도의 파이프라인 구축이 필요하며, 작은 설정 변경에도 이미지를 새로 빌드해야 하는 번거로움이 있습니다.

어떤 방법을 선택할지는 요구사항에 따라 다릅니다. 간단한 개인 프로젝트라면 셸 스크립트로 충분할 수 있지만, 팀 단위로 협업하거나 프로덕션 환경을 구축한다면 Ansible과 같은 구성 관리 도구를 도입하는 것이 장기적으로 훨씬 효율적입니다. 대규모 서비스를 빠르고 안정적으로 배포해야 한다면 Packer를 이용한 골든 이미지 방식이 가장 강력한 해결책이 됩니다.

---
### 셸 스크립트 실행 방법

1. 스니펫(Snippet)이란?

컴퓨터 프로그래밍에서 '스니펫'은 일반적으로 "재사용할 수 있는 작은 코드 조각"을 의미합니다.

Proxmox VE의 맥락에서 스니펫은 여러 가상 머신(VM)과 컨테이너에서 반복적으로 사용될 수 있는 작은 설정 파일 조각을 의미합니다. 이 파일들은 Proxmox 서버의 특정 저장소에 보관되며, 필요할 때마다 쉽게 가져와서 적용할 수 있습니다.

2. 스니펫의 주요 용도

스니펫은 주로 다음과 같은 용도로 사용됩니다.

- Cloud-Init 설정 파일 저장 (가장 일반적인 용도):
  - User-Data: VM이 처음 부팅될 때 실행할 셸 스크립트나 Cloud-Config YAML 파일(패키지 설치, 사용자 생성 등)을 저장합니다.
  - Network-Config: 고정 IP 주소 등 복잡한 네트워크 설정을 정의하는 파일을 저장합니다.

  - 훅 스크립트 (Hookscript) 저장:
    - VM이 특정 상태(예: 시작, 정지, 백업, 마이그레이션)가 될 때마다 자동으로 실행되는 스크립트를 저장하는 데 사용됩니다. 예를 들어, 'VM이 시작될 때마다 특정 API를 호출해라'와 같은 자동화 로직을 구현할 수 있습니다.

3. 스니펫의 저장 위치

- 스니펫은 Proxmox 노드의 특정 스토리지(Storage)에 저장됩니다.
- 단, 아무 스토리지에나 저장할 수 있는 것은 아니고, 해당 스토리지의 '콘텐츠(Content)' 타입 설정에 '스니펫(Snippets)'이 허용되어 있어야 합니다.
- 대부분의 기본 Proxmox 설치 환경에서는 local이라는 이름의 스토리지가 이 역할을 하며, 실제 서버에서의 경로는 /var/lib/vz/snippets/ 디렉터리입니다.

4. 스니펫 사용 방법

  - Proxmox 관리자 계정으로 접속합니다
  - /var/lib/vz/snippets/ 폴더에 원하는 이름(예 : cloud-init.yaml) 으로 스니펫 파일을 저장합니다.

- Terraform에서 사용 (API 호출):
  - VM 리소스의 cicustom 파라미터를 사용하여 참조합니다.
    - cicustom = "vendor=local:snippets/cloud-init.yaml"
    - vendor=: 이 스니펫을 Cloud-Init의 User-Data로 사용하겠다는 의미입니다.
    - local: 스니펫이 저장된 스토리지의 ID입니다.
    - :snippets/...: 스토리지 내의 스니펫 경로와 파일명을 의미합니다.

5. 스니펫 사용의 장점

- 재사용성: 하나의 표준 Cloud-Init 설정 스니펫을 만들어두면, 수십 또는 수백 개의 VM에 동일한 설정을 일관되게 적용할 수 있습니다.
- 중앙 관리: 공통 설정들이 Proxmox 서버의 한곳에 모여있기 때문에 관리가 매우 편리합니다. 설정 변경이 필요할 때, 스니펫 파일 하나만 수정하면 됩니다.
- 관심사 분리 (Separation of Concerns): 인프라의 구조를 정의하는 Terraform 코드와 VM 내부 설정을 정의하는 Cloud-Init 코드를 물리적으로 분리할 수 있습니다. 이로 인해 코드가 더 깔끔해지고 유지보수가 쉬워집니다.
- 체계적인 관리: 스니펫의 원본 파일(cloud_init.cfg 등)은 Git으로 버전 관리를 하고, Terraform을 통해 Proxmox에 배포하는 체계적인 워크플로우를 구축할 수 있습니다.

Proxmox의 스니펫은 반복적인 VM 설정을 표준화하고 중앙에서 관리하기 위한 매우 효율적인 기능입니다.

---

### qemu-guest-agent 프로그램을 Cloud-Init 기능을 이용하여 초기화

파일 구조 

step6
├── cloud_init.yml     # cloud-init 관련 초기화 작업을 파일 
├── provider.tf
├── step6.tf           # cloud-init 설정 수정 
├── terraform.tfvars
└── variables.tf

1. `cloud_init.yaml` 파일 생성:
  * qemu-guest-agent를 설치하고 활성화하는 명령이 포함된 Cloud-Init 설정 파일(cloud_init.cfg)을 작성합니다. 이 파일은 YAML 형식으로 작성되어 있으며, VM이 처음 부팅될 때 Cloud-Init 서비스에 의해 해석되어 실행됩니다.
  * 파일은 관리자가 scp 명령으로 /var/lib/vz/snippets/ 폴더에 복사한다
  * 또는 관리자가 proxmox 서버에 접속하여 /var/lib/vz/snippets/ 폴더에 직접 파일을 만든다
  * 여기서 관리자가 proxmox 서버에 접속하여 vi 편집기 작성합니다

```bash
vi cloud-config.yml

#cloud-config
# 이 파일은 VM의 첫 부팅 시 Cloud-Init이 사용하는 설정입니다.
# qemu-guest-agent 서비스를 시작하고, 부팅 시 자동으로 실행되도록 활성화합니다.
runcmd:
  - apt update
  - apt install -y qemu-guest-agent
  - systemctl start qemu-guest-agent
  - systemctl enable qemu-guest-agent
  - touch /etc/cloud/cloud-init.disabled  
```

2. `step6.tf` 파일 수정:
  * `proxmox_vm_qemu` 리소스에 `cicustom` 파라미터 추가:
  * 생성되는 VM(proxmox_vm_qemu.ubuntu_vm)에 cicustom 파라미터를 추가하여, 위에서 업로드한 Cloud-Init 스니펫 파일을 user-data로 사용하도록 지시합니다. cicustom = "vendor=local:snippets/cloud_init.yml" 이 부분이 새로 생성된 스니펫을 VM에 연결하는 역할을 합니다.

```bash
vi step6.tf

# Proxmox VM 리소스 정의
resource "proxmox_vm_qemu" "ubuntu_vm" {
  # VM의 이름 설정
  name        = var.vm_name
  # VM이 배포될 Proxmox 노드의 이름
  target_node = var.proxmox_node
  # 복제할 템플릿의 이름
  clone       = var.template_name
  # VM 생성 시 풀 클론(독립적인 복사본)을 수행할지 여부
  full_clone  = true

  # 운영체제 타입 설정 (Cloud-Init을 사용)
  os_type = "cloud-init"
  # QEMU Guest Agent 활성화 (VM과 호스트 간 통신)
  agent   = 1

  # CPU 설정
  cpu {
    # 할당할 CPU 코어 수
    cores = 1
    # 할당할 CPU 소켓 수
    sockets = 1
  }

  # 할당할 메모리 양 (MB 단위)
  memory  = 1024
  # 메모리 벌루닝 활성화 (최소 512MB 보장)
  balloon = 512
  # SCSI 컨트롤러 하드웨어 타입 (성능 향상을 위해 VirtIO SCSI 권장)
  scsihw  = "virtio-scsi-pci"
  # 부팅 순서 (scsi0 디스크로 부팅)
  boot    = "order=scsi0"

  # 메인 디스크 설정 (루트 디스크)
  disk {
    # 디스크 슬롯 (scsi0)
    slot    = "scsi0"
    # 디스크 크기 (8GB)
    size    = "8G"
    # 디스크 종류 (일반 디스크)
    type    = "disk"
    # 디스크 저장소 (예: local-lvm)
    storage = "local-lvm"
  }

  # Cloud-Init 드라이브 설정
  disk {
    # 디스크 슬롯 (ide2는 일반적으로 Cloud-Init CD-ROM 드라이브에 사용)
    slot    = "ide2"
    # 디스크 종류 (Cloud-Init 드라이브)
    type    = "cloudinit"
    # 디스크 저장소
    storage = "local-lvm"
  }


  # 네트워크 인터페이스 설정
  network {
    # 네트워크 인터페이스 ID (net0)
    id     = 0
    # 네트워크 카드 모델 (VirtIO는 성능이 좋음)
    model  = "virtio"
    # 연결할 가상 브릿지
    bridge = "vmbr0"
  }

  # Cloud-Init을 통한 IP 설정 (DHCP로 IP 자동 할당)
  ipconfig0 = "ip=dhcp"

  # Cloud-Init 업그레이드 활성화
  ciupgrade  = true
  # Cloud-Init 사용자 이름
  ciuser     = var.ciuser
  # Cloud-Init 사용자 암호
  cipassword = var.cipassword
  # SSH 공개 키 (VM에 SSH 접속용)
  sshkeys    = var.ssh_public_key

  # 사용자 정의 Cloud-Init 설정 적용
  # 위에서 생성한 스니펫 파일을 'vendor' 데이터로 이 VM에 적용합니다.
  cicustom = "vendor=local:snippets/cloud_init.yml"

  # VGA 설정
  vga {
    # VGA 타입 (표준)
    type = "std"
  }

  # Terraform 라이프사이클 관리 설정
  lifecycle {
    # 특정 속성의 변경을 Terraform이 무시하도록 설정 (수동 변경 시 유용)
    ignore_changes = [
      network, # 네트워크 설정 변경 무시
      disk     # 디스크 설정 변경 무시
    ]
  }
}

```

결과적으로: 이제 VM이 부팅되면서 Proxmox에 저장된 Cloud-Init 스니펫(cloud_init.cfg)을 읽어 자동으로 qemu-guest-agent를 설치하고 활성화하게 됩니다. 이 방식은 VM의 초기화 과정을 더 일관되고 안정적으로 만들어 줍니다.

#### 실행 방법:
```bash
terraform init
terraform plan
terraform apply -auto-approve
```


생성된 가상 머신에 접속해 봅니다
```
userid : kosa
password : kosa1004
```
입력하면 로그인이 되는 것을 확인할 수 있습니다


로그인 한 후 ip a로 ip의 주소를 확인하고 ssh로 접속할 때 공개키로 접속이 되는 것을 확인할 수 있습니다

실행 후 경고 출력되지 않고 빠르게 완료되는 것을 확인할 수 있습니다

생성된 가상머신의 요약에 부분에 IP 주소가 표시됩니다.