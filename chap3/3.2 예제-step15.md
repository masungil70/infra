## `for_each`를 사용하여 다양한 사양의 VM 그룹 관리하기

for_each는 count보다 더 유연하며, 맵(map)이나 세트(set)를 기반으로 각기 다른 속성을 가진 리소스 그룹을 관리할 때 매우 강력합니다. 예를 들어, 웹 서버 2대와 DB 서버 1대를 각각 다른 사양으로 한 번에 생성할 수 있습니다.

VM들의 사양을 정의하는 변수를 variables.tf에 아래와 같아 정의 합니다
```
vi variables.tf
...
# vms.auto.tfvars 파일에서 값을 받아올 변수 선언
variable "vms" {
type = map(object({
    name    = string  # VM 이름
    cores   = number  # CPU 코어 수
    memory  = number  # 메모리 크기 (MB)
    disk_gb = number  # 디스크 크기 (GB)
    tags    = string  # 태그
  }))
}

```

VM들의 사양을 정의하는 변수에 값은 vms.auto.tfvars 파일에 아래와 같아 대입 합니다.

```
vi vms.auto.tfvars
# 이 파일은 .auto.tfvars로 끝나므로 terraform이 자동으로 로드합니다.
# 생성할 VM들의 정보를 맵(map) 형태로 정의
vms = {
  "web1" = {
    name    = "production-web-01"
    cores   = 2
    memory  = 2048
    disk_gb = 25
    tags    = "web;prod"
  },
  "web2" = {
    name    = "production-web-02"
    cores   = 2
    memory  = 2048
    disk_gb = 25
    tags    = "web;prod"
  },
  "db1" = {
    name    = "production-db-01"
    cores   = 4
    memory  = 4096
    disk_gb = 50
    tags    = "db;prod"
  }
}
```

이제 이 변수를 사용하여 VM들을 생성하는 메인 파일을 작성합니다.

```
vi step15.tf
# Proxmox VM 리소스 정의
resource "proxmox_vm_qemu" "ubuntu_vm" {
  # for_each를 사용하여 var.vms 맵의 각 항목에 대해 리소스를 생성
  # 각 리소스는 "web1", "web2", "db1"과 같은 키로 식별됨
  for_each = var.vms

  # --- 기본 정보 ---
  # each.key는 맵의 키(web1, db1 등), each.value는 맵의 값(객체)
  name        = each.value.name
  target_node = var.proxmox_node
  tags        = each.value.tags

...

  # CPU 설정
  cpu {
    # 할당할 CPU 코어 수
    cores = each.value.cores
    # 할당할 CPU 소켓 수
    sockets = 1
  }

  ...

  # 메인 디스크 설정 (루트 디스크)
  disk {
    # 디스크 슬롯 (scsi0)
    slot    = "scsi0"
    # 디스크 크기 (8GB)
    size    = "${each.value.disk_gb}G"
    # 디스크 종류 (일반 디스크)
    type    = "disk"
    # 디스크 저장소 (예: local-lvm)
    storage = "local-lvm"
  }

  ...

```

### 실행 방법:
* terraform apply를 실행하면 vms.auto.tfvars 파일에 정의된 사양대로 웹 서버 2대와 DB 서버 1대가 각각 다른 이름과 사양으로 생성됩니다.

```bash
terraform init
terraform plan
terraform apply -auto-approve
```

생성된 3개의 가상 머신에 접속해 봅니다
```
userid : kosa
password : kosa1004
```
입력하면 로그인이 되는 것을 확인할 수 있습니다

* terraform apply의 실행결과로 server_ip을 확인해봅니다.
* 생성된 가상머신에 로그인하여 ip a 명령으로 ip을 확인합니다.
* server_ip와 ip a 명령의 결과 같은지 확인합니다.

* ip의 주소(예 : 192.168.0.4)으로 ssh로 접속할 때 공개키로 접속이 되는 것을 확인할 수 있습니다

이처럼 단계적으로 Terraform의 기능을 활용하면, 단순 반복 작업부터 복잡하고 다양한 인프라 구성까지 모두 코드로 깔끔하게 관리할 수 있게 됩니다.
