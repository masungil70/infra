## list(string)을 for_each 구문 사용법 

list는 for_each와 직접 사용할 수 없습니다. list는 순서가 있는 목록이며, 이 순서는 Terraform이 리소스를 고유하게 식별하는 데 불안정한 요소가 될 수 있기 때문입니다.

list를 for_each에 사용하려면, toset() 함수를 이용해 list를 set으로 변환해야 합니다.

count를 사용하지 않고 정적 IP를 3개를 list을 이용하여 선언하고 사용하는 예제를 알아보겠습니다.
list에 중복된 값이 있는 경우 set으로 변환을 해서 사용하기 때문에 중복값은 제거되서 처리합니다 

1. list을 사용한 변수선언 

variables.tf 파일에 아래와 같이 정의 합니다

```
vi variables.tf 
...
variable "static_ips" {
  type        = list(string)  #type을 list으로 설정합니다
  description = "VM에 할당할 정적 IP 주소들"
}

variable "static_ip_cidr" {
  type        = number
  description = "정적 IP의 CIDR 접두사 (예: 24)"
}

variable "static_gateway" {
  type        = string
  description = "VM의 기본 게이트웨이 주소"
}

```

2. 변수 값 설정

선언된 변수에 값을 설정하는 것은 terraform.tfvars 파일에 아래와 같이 대입합니다

```
vi terraform.tfvars
...

# 네트워크 정보(일부터 ip를 중복으로 정의해본 것임 )
static_ips = ["192.168.0.4", "192.168.0.5", "192.168.0.4"]
static_ip_cidr = 24
static_gateway = "192.168.0.1"

```


3. 선언된 변수의 값 사용

```
vi step14.tf
# Proxmox VM 리소스 정의
resource "proxmox_vm_qemu" "ubuntu_vm" {
  # toset(var.static_ips) (list 타입)의 각 요소에 대해 반복합니다.
  for_each = toset(var.static_ips)
...

  # Cloud-Init을 통한 IP 설정 (정적 IP 할당)
  # set의 각 요소를 반복하면서 각각의 IP 주소를 할당합니다.
  # set의 각 요소를 each.key는 for_each로 반복되는 현재 요소의 값입니다. 
  # set의 각 요소를 each.value는 for_each로 반복되는 현재 요소의 값입니다. 
  # 즉 set의 각 요소를 each.key와 each.value는 동일한 값을 가리킵니다.
  ipconfig0 = "ip=${each.key}/${var.static_ip_cidr},gw=${var.static_gateway}"
...
}
```

 list으로 설정된 값 출력 

```
vi outputs.tf

output "server_ips" {
  description = "서버의 기본 IPv4 주소입니다."
  value = {
    for k, v in proxmox_vm_qemu.ubuntu_vm : k => v.default_ipv4_address
  }
}
```

#### 실행 방법:
```bash
terraform init
terraform plan
terraform apply -auto-approve

실행결과 
...
Plan: 2 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + server_ips = {
      + "192.168.0.4" = (known after apply)
      + "192.168.0.5" = (known after apply)
    }

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

proxmox_vm_qemu.ubuntu_vm["192.168.0.5"]: Creating...
proxmox_vm_qemu.ubuntu_vm["192.168.0.4"]: Creating...
proxmox_vm_qemu.ubuntu_vm["192.168.0.5"]: Still creating... [00m10s elapsed]
proxmox_vm_qemu.ubuntu_vm["192.168.0.4"]: Still creating... [00m10s elapsed]
proxmox_vm_qemu.ubuntu_vm["192.168.0.5"]: Still creating... [00m20s elapsed]
proxmox_vm_qemu.ubuntu_vm["192.168.0.4"]: Still creating... [00m20s elapsed]
proxmox_vm_qemu.ubuntu_vm["192.168.0.5"]: Creation complete after 25s [id=masungil1/qemu/104]
proxmox_vm_qemu.ubuntu_vm["192.168.0.4"]: Still creating... [00m30s elapsed]
proxmox_vm_qemu.ubuntu_vm["192.168.0.4"]: Still creating... [00m40s elapsed]
proxmox_vm_qemu.ubuntu_vm["192.168.0.4"]: Still creating... [00m50s elapsed]
proxmox_vm_qemu.ubuntu_vm["192.168.0.4"]: Creation complete after 50s [id=masungil1/qemu/105]

Apply complete! Resources: 2 added, 0 changed, 0 destroyed.

Outputs:

server_ips = {
  "192.168.0.4" = "192.168.0.4"
  "192.168.0.5" = "192.168.0.5"
}
```

생성된 2개의 가상 머신에 접속해 봅니다
```
userid : kosa
password : kosa1004
```
입력하면 로그인이 되는 것을 확인할 수 있습니다

* terraform apply의 실행결과로 server_ip을 확인해봅니다.
* 생성된 가상머신에 로그인하여 ip a 명령으로 ip을 확인합니다.
* server_ip와 ip a 명령의 결과 같은지 확인합니다.

* ip의 주소(예 : 192.168.0.4)으로 ssh로 접속할 때 공개키로 접속이 되는 것을 확인할 수 있습니다
